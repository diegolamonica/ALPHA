<?php
/**
 * @author Diego La Monica
 * @version 2.3
 * @name Model
 * @package ALPHA
 * @uses Debugger
 */

class Model extends Debugger {
	/*
	 * ChangeLog:
	 * 
	 * V 2.0
	 * - Refactored a lot of source code
	 * - Better memory management
	 * - Improved Variable management
	 * - Refactoring of constants
	 * - Better documented (need more documentation)
	 * - Partially removed debug calls: 
	 *   - to improve performances
	 *   - in favour of uint tests 
	 *   
	 * V 2.1
	 * - Optimized code to improve performance (800% faster)
	 * - Complete removal of debug calls
	 * - Improved ClearSubvar method 
	 * - Improved documentation
	 * - minor bugfix
	 *
	 * V 2.2
	 * - Some improvements in the Cache Manager
	 * - Added private method replaceVar (to improve general templating performance)
	 * - Minor bugfixes
	 * - added 'count' variable to iterator
	 * - set the scope (public / private) for the class methods
	 * - Improved documentation
	 *
	 * V 2.3
	 * - Introduced the new cuteml element {break:var}
	 * - removed an undefined variable from replaceVar() method
	 *
	 */
	const VERSION = '2.3';

	const KEYWORD_PHP_BLOCK_START = 'php';
	const KEYWORD_PHP_BLOCK_END = 'phpend';

	
	/**
	 * Keyword to identify the start of a loop block
	 * <code>
	 * {foreach:item}
	 * 		...
	 * {loop}
	 * </code>
	 * @var String
	 */
	const KEYWORD_LOOP_START = 'foreach';
	
	/**
	 * Keyword to identify the end of a loop block.
	 * <code>
	 * {foreach:item}
	 * 		...
	 * {loop}
	 * </code>
	 * @var String
	 */
	const KEYWORD_LOOP_END = 'loop';
	
	
	const KEYWORD_LOOP_BREAK = 'break';
	
	/**
	 * Keyword to identify a variable in the template
	 * @var String
	 */
	const KEYWORD_VAR = 'var';
	
	/**
	 * Keyword to identify a set variable action in the template
	 * @var String
	 */
	const KEYWORD_SETVAR = 'setvar';
	
	/**
	 * Conditional block keyword start
	 * <code>
	 * {if: <i>inline php block code</i>}
	 * {endif}
	 * @var String
	 * @see KEYWORD_IF_END
	 * @see KEYWORD_IF_ELSE
	 */
	const KEYWORD_IF_START = 'if';
	
	
	/**
	 * Conditional block keyword else
	 	* <code>
	 * {if:<i>inline php block code</i>}
	 * {endif}
	 * @var String
	 * @see KEYWORD_IF_START
	 * @see KEYWORD_IF_END
	 */
	
	const KEYWORD_IF_ELSE = 'else';
	
	const KEYWORD_IFVAR_START = 'ifv';
	
	/**
	 * Conditional block keyword end
	 * <code>
	 * {if: <inline php block code>}
	 * {endif}
	 * @var String
	 * @see KEYWORD_IF_START
	 * @see KEYWORD_IF_ELSE
	 */
	const KEYWORD_IF_END = 'endif';
	
	/**
	 * Keywort that identifies a function
	 * @var String
	 * @see FUNCTIONSROOT
	 */
	const KEYWORD_FUNCTION = 'fn';
	
	/**
	 * Keyword that identify a file inclusion.
	 * The output generated by the included file will be parsed and will replace the cuteml element.
	 * Beware!!! In opposition to the include-static inclusion mode the included file has executed
	 * in the current context and the script will be able to access all data.
	 * @var String
	 * @see KEYWORD_INCLUDE_STATIC
	 */
	const KEYWORD_INCLUDE = 'include';
	/**
	 * Keyword to include a fragment of the page (out of the scope).
	 * @var String
	 */
	const KEYWORD_INCLUDE_STATIC = 'include-static';
	const KEYWORD_REDIRECT = 'redirect';
	
	
	private $viewFileName = '';
	private $viewName = DEFAULT_VIEW_NAME;
	private $buffer = '';
	private $storedFromCache = false;
	private $_doNotSendHeader = false;
	
	private $currentIterationBlock = '';
	private $loopBreakFor			= '';
	/**
	 * Contain all the variables expoesed to the template
	 * @var array 
	 */
	static $variables = array();
	
	/**
	 * List of all variable which is disallowed the HTML escaping
	 * @var array
	 */
	static $disallowedEscapeOn = array();
	
	/**
	 * Will be true if the model is rendering or processing a plugin
	 * @var boolean 
	 */
	public $isPlugin = false;
	
	/**
	 * Tell if the Model is currently parsing a loop block.
	 * @var boolean
	 */
	public $inLoop = false;
	
	private $ignoreCache = false;
	
	/**
	 * Contains all HTML elements to put in the <head /> block of the current processed page.
	 * @var array 
	 */
	public static $headers = array();
	
	/**
	 * Contains all the javascript that will be added in a <script /> block into the <head /> of the page.  
	 * @var array
	 */
	public static $startupScripts = array();
	
	/**
	 * Store all the scripts to put into a DOMReady Javascript event on the current page.
	 * @var array 
	 */
	public static $headerScripts = array();


	/**
	 * Questo metodo indica al Modello di non inviare al browser nessun header
	 * @return null
	 */
	public function doNotSendHeader(){
		$this->_doNotSendHeader = true;
	}

	public function disallowEscapeOn($varName){

		self::$disallowedEscapeOn[] = "{var:$varName}";

	}

	/**
	 * When the Model is instantiated it will expose the current data to the template:
	 * alpha:
	 * - URI: 		the $_SERVER['REQUEST_URI'] data
	 * - REFERER: 	the $_SERVER['HTTP_REFERER'] of the page
	 * - URIE:		the url encoded format of the URI component 	
	 * 
	 * @var bool $init (optional), default is true. If true will expose the 'alpha' variable to the template
	 * @var bool $doNotSendHeaders (optional), default is false, If true avoid the send of html content type
	 * @var string $viewBuffer (optional), default is empty string, if set it will be used as template
	 * @return Model
	 */
	public function __construct($init = true, $doNotSendHeaders = false, $viewBuffer = ''){
		parent::__construct();
		if($init){
			$this->setVar('alpha', array(
				'URI'=> $_SERVER['REQUEST_URI'],
				'REFERER'=> isset($_SERVER['HTTP_REFERER'])?$_SERVER['HTTP_REFERER']:'',
				'URIE' => rawurlencode(rawurlencode($_SERVER['REQUEST_URI']))
			));
		}
		
		$this->_doNotSendHeader = $doNotSendHeaders;
		$this->buffer = $viewBuffer;
		
	}

	/**
	 * Aggiunge il codice Javascript nel blocco di startup se <b>$startup = true</b> altrimenti
	 * lo inserisce come codice javascript generale nella pagina (inserito sempre nel blocco head della pagina).
	 * @param $value <b>string</b> Codice Javascript
	 * @param $startup <b>boolean</b> <code>default è false</code> se impostato a true la stringa viene considerato codice Javascript da inserire nel blocco di startup
	 * @return null
	 */
	public static function appendScripts($value, $startup = false){

		if($startup)
			$h = &self::$startupScripts;
		else
			$h = &self::$headerScripts;
		$value = trim($value);
		if($value!=''){
			if(array_search($value, $h, true)===false)
				$h[] = $value;
			
		}

	}

	/**
	 * Aggiunge la riga di inclusione per integrare fogli di stile, javascript o meta tag customizzati.
	 * Se la riga già esiste negli headers non viene inclusa.
	 * @param $headers <b>string</b> è la riga da aggiungere nel blocco <code>head</code>
	 * @return null
	 */

	public static function appendHeaders($headers){

		$h = &self::$headers;
		foreach($headers as $value){
			$value = trim($value);
			if($value!=''){
				if(array_search($value, $h, true)===false)
					$h[] = $value;
					
			}
		}

	}


	/**
	 * Imposta il modello HTML/CUTEML da utilizzare sulla pagina.
	 * Il nome della vista deve coincidere con il percorso a partire dalle indicazioni
	 * della costante <code>APPLICATION_VIEW_BASEDIR</code> senza l'estensione.
	 * Una vista deve avere estensione <strong>.htm</strong>
	 *
	 * @param $viewName <b>string</b> il nome della vista da utilizzare
	 * @return null
	 */
	public function setView($viewName){
		
		$this->viewName = $viewName;
		$this->viewFileName = APPLICATION_VIEW_BASEDIR .'/'. $viewName .'.htm';
		$h = fopen($this->viewFileName, "r");
		$this->buffer = fread($h, filesize($this->viewFileName));
		fclose($h);
		
	}


	/**
	 * Imposta il modello da HTML/CUTEML da utilizzare adottando la stringa $buffer.
	 * @param $buffer <b>string</b> Il buffer del modello da utilizzare
	 * @return null
	 */
	public function setViewFromBuffer($buffer){
		
		$this->buffer = $buffer;
		
	}
	
	
	private function createVar($variableName, $variableValue, &$variableContainer, $method = 'update'){
		// In the case of a complex object (see Unit Test #8 up to #15 )
		if(is_object($variableValue) || is_array($variableValue)){
			
			foreach($variableValue as $key => $value){
				/*
				 * Recall itself one level deeper
				 */
				$this->createVar("$variableName.$key", $value, $variableContainer, $method);
			}
			
		}else{
			/* 
			 * while the current variableName is not a number i have to traverse the variables tree
			 */ 
			if(!is_numeric($variableName) ){
				/*
				 * Identify the base name and the subvariable name
				 */
				$variableNames = preg_split('#\.#', $variableName, 2);
				$variableName = $variableNames[0];
				if(count($variableNames)==1 ){
					if(is_null($variableValue) && $method=='unset'){
						/*
						 * If the request comes from clearVar maybe I got 'unset' a $method,
						 * it means that I have to throw the enteire object (not the single value) 
						 */ 
						unset($variableContainer[$variableName]);
						return ;
					}else{  
						/*
						 * If this is the last deep level i have to create an index element
						 */
						return self::createVar(0, $variableValue, $variableContainer[$variableName], $method);
					}
				}else{
					/*
					 * Going deep further
					 */
					return self::createVar($variableNames[1], $variableValue, $variableContainer[$variableName], $method);
				}
			}else{
				/*
				 * Writing the variable
				 */
				$variableContainer[$variableName] = $variableValue;
			}
		}	
		
	}
	
	private function replaceVar($variableName, $variableValue, &$variableContainer){
		
		/*
		 * Identify the base name and the subvariable name
		 */
		$variableNames = preg_split('#\.#', $variableName, 2);
		$variableName = $variableNames[0];
		if(count($variableNames)==1 ){
			/*
			 * Writing the variable
			 */
			$variableContainer[$variableName] = $variableValue;
		}else{
			/*
			 * Going deep further
			 */
			self::createVar($variableNames[1], $variableValue, $variableContainer[$variableName]);
		}
		
	}
	
	/**
	 * Expose a variable to the template.
	 * @param string $key: is the key used in CUTEML
	 * @param any $value: is the assigned value
	 *
	 * @uses Model::createVar()
	 */
	public function setVar($key, $value){
		
		# $this->variables[$key] = $value;
		$key = preg_replace('/\%([0-9A-F]{2})/ie', 'chr(hexdec("\\1"))', $key);
		$this->createVar($key, $value, self::$variables, 'update');
	}

	/**
	 * Apply an immediate <em>Perl RegExp</em> transformation to the value stored in the given key
	 * @param $key string: the name of the key
	 * @param $from string: the matching pattern
	 * @param $to string: the transforamtion pattern
	 * @return null
	 */
	public function setReplacementRule($key, $from, $to){
		# Modifica del 26-02-2010 di Diego La Monica
		# $this->variables[$key] = preg_replace($from, $to, $this->variables[$key]);
		#self::$variables[$key] = preg_replace($from, $to, self::$variables[$key]);
		$value = $this->getVar($key);
		$this->setVar($key,  preg_replace($from, $to, $value));
	}

	/**
	 * Internal method to adjust the HTML tag selection.
	 * Returns the given 'item' and the part of HTML that matches the enteire block. 
	 * It is used by 'process' method.
	 *
	 * @param string $buffer
	 * @param string $item
	 * @return array
	 */
	private function getHtmlTag($buffer, $item){

		if (preg_match('/<([a-z]+)[^>]*>/s', $item, $tag)) {
			$tag = $tag[1];
		} else {
			
			/*
			 * Something goes wrong?
			 */
			return array($item, '');
		}
		
		/*
		 * The first char in the Inner HTML of the given block
		 */
		$i = strpos($buffer, $item);
		$i = $i+strlen($item);
				
		/*
		 * Then searching for the closing tag (and for a nested tag)
		 */
		$j = strpos($buffer, '</' . $tag . '>', $i);
		$k = strpos($buffer, '<' . $tag, $i);
		
		/*
		 * Continue with the search until i got further nested tags. 
		 */
		while($k<$j && $k>$i){
			
			/*
			 * there is an internal tag, so i must look for the next closing tag.
			 */
			$j = strpos($buffer, '</' . $tag . '>', $j+1);
			$k = strpos($buffer, '<' . $tag, $k+1);
			if($j===false){
				/* 
				 * there is a malformed markup! 
				 */
				return array($item, '');
			}
		}
		/*
		 * I've identified the whole block so I'm building it and output it!
		 */
		$item = $item . substr($buffer, $i, ($j-$i)) . '</' . $tag .'>';
		$html = substr($buffer, $i, ($j-$i) -1);
		return array($item, $html);
	}

	/**
	 * Preleva il rendering della vista dalla cache
	 * @return string
	 */
	private function retrieveFromCache($buffer){
		
		if (preg_match('/<!--\\s+CACHE MANAGER(.*?)-->\s*/si', $buffer, $defaultCacheBuffer)) {
			$buffer = '';
			// Esiste un controllo per la cache
				
			// 1. estraggo i parametri che fanno il controllo della cache
			# La sintassi dell'header di cache è:
			# <!-- CACHE MANAGER
			# @flushon=			POST
			# @modelKeyVar=		PROPDOCUM,elencoProvAbilitate
			# @expiresAfter=	1W
			# @cacheFileName= 	impianti
			# @removeOnFlush=	elenco degli elementi di cache da rimuovere (separati da virgola)
			# -->
			$defaultCacheBuffer= $defaultCacheBuffer[1];
			$cacheDirectory = CACHE_DEFAULT_FOLDER.'/';
			preg_match_all('/@(.*?)=\\s*(.*?)\\r?\\n/si', $defaultCacheBuffer, $defaultCacheAttributes, PREG_PATTERN_ORDER);
			for($attributesLoop = 0; $attributesLoop<count($defaultCacheAttributes[0]); $attributesLoop++){
				$defaultCacheKey 	= strtolower($defaultCacheAttributes[1][$attributesLoop]);
				$defaultCacheValue 	= $defaultCacheAttributes[2][$attributesLoop];
				$className = __CLASS__;
				$currentObjectStatus = $this->storeCurrentStatus();
				
				# $m = new Model(false, true, $defaultCacheValue);
				$this->_doNotSendHeader = true;
				$this->buffer = $defaultCacheValue;
				$this->isPlugin=true;
				#$m->setViewFromBuffer($defaultCacheValue);
				$cacheAttribs[$defaultCacheKey] = $this->render(true);
				
				$this->restoreCurrentStatus($currentObjectStatus);
				#$m = null;
			}
				
			// 2. verifico se mi trovo in una condizione di flush
			$fromCache = true;
			if(isset($cacheAttribs['flushon'])){
				$flushOns = preg_split('/,/',$cacheAttribs['flushon']);
				foreach($flushOns as $cacheIndex => $flushOn){
					eval('$obj = $_'.$flushOn.';');
						
					if(isset($obj) && count($obj)>0){
						$fromCache = false;
						foreach(glob("$cacheDirectory{$cacheAttribs['cachefilename']}-*.*") as $file){
							unlink($file);
						}
						$removeOnFlush = preg_split(',',$cacheAttribs['removeonflush']);
						foreach($removeOnFlush as $key => $filePrefix)
						foreach(glob("$cacheDirectory$filePrefix-*.*") as $file)
						unlink($file);


						break;
					}
				}
			}
			// 3. cerco il file nella directory opportuna
			if($fromCache){


				# La sintassi del file è:
				# 	- prefisso definito negli attributi di cache (o nulla)
				# 	- microtime (di generazione della cache)
				# 	- .cache
				$ok = false;
				foreach(glob("$cacheDirectory{$cacheAttribs['cachefilename']}-*.cache") as $file){
						
					if(file_exists($file)){

						$myFile = file($file);
						if(count($myFile)>0){
							# La prima riga contiene la data di expires
								
							if(date('Y-m-d H:i:s')>$myFile[0]){
								$expired = true;
								unlink($myFile[count($myFile)-1]);
								unlink($file);

							}else{
								# Issue #27: $expired is undefined
								$expired = false;
							}
								
							# Dalla seconda riga ci sono
							# i valori serializzati delle variabili che ho indicato come chiavi

							if(!$expired){
								$ok = true;
								$modelKeyVars = preg_split('/,/',$cacheAttribs['modelkeyvar']);
								foreach($modelKeyVars as $cacheIndex => $keyVar){
									
									$currentValue = serialize($this->getVar($keyVar, '', true));
									$cachedValue = substr($myFile[$cacheIndex+1],0,-1) ;
									
									$ok = (strcmp($cachedValue,$currentValue) ==0);
									if(!$ok) break;
								}
								if($ok) break;
							}
								
						}
					}
				}
				// 4. se disponibile ($ok = true) restituisco il buffer di cache giusto
				if($ok){
					# Il file è quello giusto, posso utilizzarlo come cache
					$buffer = file_get_contents($myFile[count($myFile)-1]);
						
					$this->storedFromCache = true;
				}
			}
		}else{
			$buffer = '';
		}

		return $buffer;
	}

	/**
	 * Salva l'output della vista corrente nella cache.
	 * @param $buffer <b>string</b> è il buffer della vista da salvare nel file di cache
	 * @return null
	 */
	private function saveCache($buffer){

		if (preg_match('/<!--\\s+CACHE MANAGER(.*?)-->\s*/si', $buffer, $defaultCacheBuffer)) {
			// Esiste un controllo per la cache
				
			// 1. estraggo i parametri che fanno il controllo della cache
			# La sintassi dell'header di cache è:
			# <!-- CACHE MANAGER
			# @flushon=			POST
			# @modelKeyVar=		PROPDOCUM,elencoProvAbilitate
			# @expiresAfter=	1W
			# @cacheFileName= 	impianti
			# -->
			$defaultCacheBuffer= $defaultCacheBuffer[1];
			preg_match_all('/@(.*?)=\\s*(.*?)\\r?\\n/si', $defaultCacheBuffer, $defaultCacheAttributes, PREG_PATTERN_ORDER);
			for($attributesLoop = 0; $attributesLoop<count($defaultCacheAttributes[0]); $attributesLoop++){
				$defaultCacheKey 	= strtolower( $defaultCacheAttributes[1][$attributesLoop] );
				$defaultCacheValue 	= $defaultCacheAttributes[2][$attributesLoop];
				$cacheAttribs[$defaultCacheKey] = $defaultCacheValue;
			}
				
			$buffer = preg_replace('/<!--\\s+CACHE MANAGER(.*?)-->\s*/si','', $buffer);
				
			// Identifico il nome corretto (e univoco) del nuovo file di cache da generare
			$cachedName = CACHE_DEFAULT_FOLDER .'/'. $cacheAttribs['cachefilename'] . '-' . date('YmdHis') . '-';
			$nextIndex = 1;
			foreach(glob($cachedName.'*') as $file){

				if(preg_match('/\-.*-(.*)\.cache/i',$file, $items)){
						
					$nextIndex = $items[1]+1;
					
				}
					
			}
			// Definisco il nome del file di cache e del file indice di cache
			$htmlCachedName = $cachedName . $nextIndex .'.html';
			$cachedName .= $nextIndex .'.cache';
			$expireUnit = substr($cacheAttribs['expiresafter'],-1);
			$expireValue = substr($cacheAttribs['expiresafter'],0,-1);
				
			// Scrivo le righe per il file di cache in un array
			$cacheFile = array();
			$cacheFile[] = date('Y-m-d H:i:s', dateAdd($expireUnit, $expireValue, date('Y-m-d H:i:s')));
				
			$modelKeyVars = preg_split('/,/',$cacheAttribs['modelkeyvar']);
			foreach($modelKeyVars as $cacheIndex => $keyVar){
				$cacheFile[] = serialize($this->getVar($keyVar, '', true));

			}
			$cacheFile[] = $htmlCachedName;
				
			// Trasformo l'array in un buffer
			$cacheFile = implode("\n", $cacheFile);
			file_put_contents($cachedName, $cacheFile);
			file_put_contents($htmlCachedName, $buffer);
				
		}
			
	}

	/**
	 * Effettua il rendering del plugin sul modello
	 * @param $mBuffer <b>string</b> è il buffer corrispondente al contenuto del file di plugin.
	 * @param $attribs <b>array</b> è l'elenco di attributi acquisiti dal tag plugin sulla vista
	 * @return string
	 */
	private function renderPlugin($mBuffer, $attribs){

		foreach($attribs as $key => $value){
			if(substr($value, 0, strlen(self::KEYWORD_VAR)+2) == '{' . self::KEYWORD_VAR .':'){
				$result = $this->parseVar($value);
				$attribs[$key]= $result[1];
			}
				
		}
		$currentObjectStatus = $this->storeCurrentStatus();
		/*
		# Storing the current template buffer
		$buffer = $this->buffer;
		# Storing the current template status
		$isPlugin = $this->isPlugin;
		$sendHeaders = $this->_doNotSendHeader;
		$storedFromCache = $this->storedFromCache;
		# Telling the Model I'm in the plugin status
		*/
		$this->buffer = $mBuffer;
		$this->isPlugin = true;
		$this->_doNotSendHeader = true;
		
		# Clean input object
		$this->clearVar('input');
		
		# Setting input object
		$this->setMultipleVar($attribs,'input');
		$mBuffer = $this->render(true);
		
		$mBuffer = $this->process($mBuffer);
		
		$this->restoreCurrentStatus($currentObjectStatus);
		/*
		$this->_doNotSendHeader = $sendHeaders;
		$this->buffer = $buffer;
		$this->isPlugin = $isPlugin;
		$this->storedFromCache = $storedFromCache;
		*/
		return $mBuffer;

	}



	/**
	 * Elabora la vista sostituendo tutte le occorrenze del codice CUTEML con gli opportuni valori
	 * @param $buffer <b>string</b> <code>default null</code> se non impostato elabora il buffer corrispondente alla vista corrente altrimenti elabora il buffer passato come parametro
	 * @return string restituisce l'elaborazione del buffer
	 */
	public function process($buffer = null){

		if($buffer == null) $buffer = $this->buffer;
		# Issue #27: $tempBuffer is undefined
		$tempBuffer = '';
		if(!$this->storedFromCache && !$this->inLoop) $tempBuffer = $this->retrieveFromCache($buffer);
		if($tempBuffer !=''){
			$buffer = $tempBuffer;
		}else{
			/*
			 * Gestisce tutti gli input di type="custom"
			 */
				
			$count = preg_match_all('/<(\w+[^>]*?type="custom".*?)\/?>/si', $buffer, $input, PREG_PATTERN_ORDER);
			$input = $input[0];
			for($i=0; $i<count($input); $i++){
				if(strpos($buffer, $input[$i])!==false){
					$theInput = str_replace("\n",' ', $input[$i]);
					preg_match_all('/([a-z_\-0-9]+)="([^"\\\]*(?:\\\.[^"\\\]*)*)"/i', $theInput, $attributes, PREG_PATTERN_ORDER);
					unset($attribs);
					for($j=0; $j<count($attributes[0]); $j++){
						$attribs[$attributes[1][$j]] = str_replace('\"','"', $attributes[2][$j]);
					}
						
						
					if(substr($theInput,-2,2)!='/>'){
						// Devo prendere anche il contenuto e metterlo nell'attributo html

						$inputResult = $this->getHtmlTag($buffer, $input[$i]);
						$input[$i] = $inputResult[0];
						$attribs['html'] = $inputResult[1];
					}
					if(!isset($attribs['inloop']) && !$this->inLoop || isset($attribs['inloop']) && (($attribs['inloop']=="true") && $this->inLoop)){
							
						// Cerca prima se esiste un input customizzato rilasciato con l'applicazione

						if(defined('APPLICATION_CUSTOM_INPUT_BASEDIR')){
							$nomeFile = APPLICATION_CUSTOM_INPUT_BASEDIR . '/'.$attribs['model'] . '.htm';
							if(!file_exists($nomeFile)){
								$nomeFile = INPUTROOT. $attribs['model'] . '.htm';
							}
						}else{
							$nomeFile = INPUTROOT. $attribs['model'] . '.htm';
						}

						$renderingArea = '';

						if(file_exists($nomeFile)){

							$mBuffer = file_get_contents($nomeFile);
								
							// Acquisisco gli attributi di default
							unset($defaultAttributes);
							if (preg_match('/<!--\\s+DEFAULT ATTRIBUTES(.*?)-->/si', $mBuffer, $defaultAttributesBuffer)) {
								$defaultAttributesBuffer= $defaultAttributesBuffer[1];
								preg_match_all('/@(.*?)=\\s*(.*?)\\r?\\n/si', $defaultAttributesBuffer, $defaultAttributes, PREG_PATTERN_ORDER);
								for($attributesLoop = 0; $attributesLoop<count($defaultAttributes[0]); $attributesLoop++){
									$defaultKey 	= $defaultAttributes[1][$attributesLoop];
									$defaultValue 	= $defaultAttributes[2][$attributesLoop];
									if(!isset($attribs[$defaultKey])) $attribs[$defaultKey] = $defaultValue;
								}
							} else {
								unset($defaultAttributes);
							}
								
							// Renderizzo l'oggetto
							$chiaveLastKey = 'input.lastkey' . md5(date('Y-m-d h:i:s')) . '_' . sha1(date('Y-m-d h:i:s'));
							$mBuffer .='{'.self::KEYWORD_VAR.':'.$chiaveLastKey. '}';
							$this->setVar($chiaveLastKey, '');
							$mBuffer = $this->renderPlugin($mBuffer, $attribs);
								
							/*
							 * A questo punto devo prendere solo le porzioni di codice che mi servono
							 */
								
							if (preg_match('/<!-- RENDER:BEGIN -->(.*)<!-- RENDER:END -->/s', $mBuffer, $renderingArea)){
								$renderingArea = $renderingArea[1];
							}else{
								$renderingArea = '';
							}
							if(preg_match('/<!-- HEADER:BEGIN -->(.*)<!-- HEADER:END -->/s', $mBuffer, $headingArea)){
								$headingArea = $headingArea[1];
							}else{
								$headingArea = '';
							}
							if (preg_match('/\/[*] script:begin [*]\/(.*)\/[*] script:end [*]\//s', $mBuffer, $headingScripts)) {
								$headingScripts = $headingScripts[1];
							} else {
								$headingScripts = "";
							}
								
							if(preg_match('/\/\\* init-script:begin \\*\/(.*)\/\\* init-script:end \\*\//si', $mBuffer, $startupScripts)){
								$startupScripts = $startupScripts[1];
							}else{
								$startupScripts = '';
							}
							$headingArea = preg_split("/\n/",$headingArea);
							self::appendHeaders($headingArea);
							self::appendScripts($headingScripts);
							self::appendScripts($startupScripts, true);
						}else{
							$input[$i] = '<!-- custom model for ' . $attribs['model'] . ' does not exists -->';
						}

						$buffer = str_replace($input[$i], $renderingArea, $buffer, $cnt);
					}
				}
			}
		}
		$this->buffer = $buffer;
		return $buffer;
	}
	/**
	 * Return the current in use buffer
	 * @return string
	 */
	public function getBuffer(){
		return $this->buffer;
	}
	
	private function storeCurrentStatus(){
		return array(
			'_doNotSendHeader' 		=> $this->_doNotSendHeader,
			'buffer' 				=> $this->buffer,
			'ignoreCache' 			=> $this->ignoreCache,
			'inLoop' 				=> $this->inLoop,
			'isPlugin' 				=> $this->isPlugin,
			'storedFromCache'	 	=> $this->storedFromCache,
			'viewFileName'			=> $this->viewFileName,
			'viewName'				=> $this->viewName,
			'currentIterationBlock'	=> $this->currentIterationBlock,
			'loopBreakFor'			=> $this->loopBreakFor
		);
	} 
	
	private function restoreCurrentStatus($status){
		foreach($status as $key => $value){
			
			$this->$key = $value;
			
		}
	}
	/**
	 * Cerca tutti i token nel buffer HTML e le converte nei valori opportuni
	 * @param $bufferedOutput <b>boolean</b> <code>default false</code> se impostato a true il metodo restituirà in output il buffer elaborato
	 * @return <b>string</b> solo se <code>$bufferedOutput = true</code> altrimenti null
	 */
	public function render($bufferedOutput=false){
		
		/*
		 * If i should send headers for the page
		 */
		if(!$this->_doNotSendHeader && !headers_sent()){
			
			header('Content-type: text/html; charset=UTF-8') ;
		}
		/*
		 * Uses local stored buffer
		 * and check for existence in the cache 
		 */
		$buffer = $this->buffer;
		if(!$this->ignoreCache && !$this->storedFromCache && !$this->inLoop){
			$tempBuffer = '';
			$tempBuffer = $this->retrieveFromCache($buffer);
			if($tempBuffer !='') $buffer = $tempBuffer;
			if($this->storedFromCache){
					
				if($bufferedOutput) return $buffer;
				echo($buffer);
			}
		}

		$savedBuffer = '';
		$first_position = 0;
		$last_first_position = 0;
		# 2008-11-29: Ho scoperto un errore: l'ultima variabile {var:...} non viene considerata
		# quindi per consentirne l'elaborazione aggiungo per ora una variabile con indicazione
		# random del suo nome

		#$chiaveLastKey = 'lastkey' . md5(date('Y-m-d h:i:s')) . '_' . sha1(date('Y-m-d h:i:s'));

		#$buffer .='{var:'. $chiaveLastKey . '}';
		#$this->setVar($chiaveLastKey,'');
		while(  preg_match('/{([a-z\-_]+):(.*)}/', $buffer, $items, null, $first_position)!=0){
			$last_first_position = strpos($buffer, $items[0]);
			if($first_position>$last_first_position) $last_first_position = $first_position;
			/*
			 * It seems that the following block is not required (it does the same as while condition: no more)!
			 * 
			if($first_position==$last_first_position){

				$lastItem = $items[0];
					
				$result = preg_match('/{([a-z\-_]+):(.*)}/', $buffer, $items, null, $first_position);

				if($result==0){
					break;
				}else{
					#	$first_position = $last_first_position+1;
				}
			}
			
			*
			*/
			$first_position = $last_first_position+1;
			$keyword = $items[1];
			$value = $items[2];
			/* 
			 * if there were some nested elements 
			 */
			if(preg_match('/{([a-z\-_]+):(.*)}/', $value)!=0){
				
				
				$currentObjectStatus = $this->storeCurrentStatus();
				
				$this->_doNotSendHeader = true;
				$this->buffer = $value;
				$this->ignoreCache = true;
				
				$value = $this->render(true);
				
				$this->restoreCurrentStatus($currentObjectStatus);
				
				
			}
			switch($keyword){
				case self::KEYWORD_REDIRECT:
					$fileToRedirect = APPLICATION_URL.$value;
					header('Location: ' . $fileToRedirect, true);
					exit();
				case self::KEYWORD_INCLUDE:
					$fileToInclude = ROOT.$value;
					ob_start();
					include $fileToInclude;
					$tmpBuffer = ob_get_clean();
					
					$currentObjectStatus = $this->storeCurrentStatus();
					
					$this->_doNotSendHeader = true;
					$this->buffer = $tmpBuffer;
					$this->process();
					$tmpBuffer = $this->render(true);
					
					$this->restoreCurrentStatus($currentObjectStatus);
					
					/*
					 * Reduced the instances of Model:
					 * - better memory management
					 * - code optimization
					 * 
					# Aggiutna del 24-05-2010 di Diego La Monica
					$im = new $thisClassName(false, true, $tmpBuffer);
					#$im->setViewFromBuffer($tmpBuffer);
					$im->process();
					$tmpBuffer = $im->render(true);
					ClassFactory::destroy('includeModel');
					# Fine Aggiutna
					*/
					$buffer = str_replace($items[0], $tmpBuffer,$buffer);
					break;
				case self::KEYWORD_INCLUDE_STATIC:
					if(!preg_match('/^https?\:\/\//',$value)){
						$fileToInclude = ROOT.$value;
					}else{
						$fileToInclude = $value;
					}
					$tmpBuffer = file_get_contents($fileToInclude);
					$buffer = str_replace($items[0], $tmpBuffer,$buffer);
					break;
				case self::KEYWORD_LOOP_START:
					$tmpBuffer = '';
						
					$loopBlock = $this->endBlockSearch($buffer, $items[0],self::KEYWORD_LOOP_START, self::KEYWORD_LOOP_END);
					$blockName = $value;
						
						
					if(preg_match('/SQL\(([^\)]+)\)::(.*)/',$blockName, $sqlResults )){
						$c = ClassFactory::get('connector');

						$c->query($sqlResults[2]);
						$this->setVar($sqlResults[1], $c->allResults());

						$blockName = $sqlResults[1];
					}
					
					# Used the new syntax (V2.0): Getting the iterable object (not the ZeroIndex Value)
					# Unit Test #14
					$tempResult = $this->getVar($blockName, null, true);

					if(is_null($tempResult)){

						# I don't like this way to get data here, because it has a lot of memory usage
						# Lambda function never destruct... is it a PHP bug or am I unable to do it???
						# Look for a solution because it's a thing useful out of there too!
						
						#$lambdaFunction = create_function("", "return $blockName;");
						#$temporaryObject = $lambdaFunction();
						
						# And I don't like this way too... it's weird and insecure.
						#eval( '$temporaryObject='. $blockName . ';');
							
						# This way is cleaner than both lambda and eval.
						$availableObjects = array();
						isset($_GET) 		&& $availableObjects['$_GET'] 		= $_GET;
						isset($_POST) 		&& $availableObjects['$_POST'] 		= $_POST;
						isset($_COOKIE) 	&& $availableObjects['$_COOKIE'] 	= $_COOKIE;
						isset($_ENV) 		&& $availableObjects['$_ENV'] 		= $_ENV;
						isset($_FILES) 		&& $availableObjects['$_FILES'] 	= $_FILES;
						isset($_REQUEST) 	&& $availableObjects['$_REQUEST'] 	= $_REQUEST;
						isset($_SERVER) 	&& $availableObjects['$_SERVER'] 	= $_SERVER;
						isset($_SESSION) 	&& $availableObjects['$_SESSION'] 	= $_SESSION;
						
						if(isset($availableObjects[$blockName])){
							/*
							 * If exists i will create the temporary object
							 * and the blockName else it will be undefined
							 */
							$temporaryObject = $availableObjects[$blockName];
							$this->setVar($blockName, $temporaryObject);
						}
						/*
						 * And if it's undefined the tempResult used for the iteration
						 * will be null 
						 */
						$tempResult = $this->getVar($blockName, null, true);

					}
					
					$lastVariables = null;
					if(is_array($tempResult)){
						
						/*
						 * Storing current object status
						 */
						$currentObjectStatus = $this->storeCurrentStatus();
						/*
						 * In the loop we dont need to send the headers every time, let the 
						 * main render method to do as needed.
						 * Again we not need to check in the cache for an available block,
						 * maybe in the will we need to discuss about fragmented cache.
						 * 
						 */
						$this->inLoop 					= true;
						$this->_doNotSendHeader 		= true;
						$this->ignoreCache 				= true;
						$this->storedFromCache			= false;
						
						$this->currentIterationBlock 	= $blockName;
						$i = 0;
						/*
						 * Storing the current iterator (useful for nested var).
						 */
						$tempIterator = $this->getVar('iterator', null, true);
						
						$totalResults = count($tempResult);
						$tmpBufferArray = array();
						
						foreach($tempResult as $key => &$value){
							
							$this->buffer = $loopBlock;
							
							$i+=1;
							/*
							 * The direct way is faster than single setVar call, it's obvious.
							 * If we decide to change the way we store data in the template
							 * variable structure, well we can back with the code. 
							 */
							#$this->setVar('iterator', $i);
							self::$variables['iterator'][0] = $i;
							
							#$this->setVar('iterator.key', $key);
							self::$variables['iterator']['key'][0] = $key;
							
							#$this->setVar('iterator.value', $value);
							self::$variables['iterator']['value'] = $value;

							/**
							 * @since 2.2
							 */
							#$this->setVar('iterator.prev', $lastVariables);
							self::$variables['iterator']['count'][0] = $totalResults;
								
							#$this->setVar('iterator.last', ($i == $totalResults));
							self::$variables['iterator']['last'] = ($i == $totalResults);
							
							#$this->setVar('iterator.prev', $lastVariables);
							self::$variables['iterator']['prev'] = $lastVariables;
							
							/*
							 * Creating the object structure for the current iterator item.
							 * Here an hypotetic structure like:
							 *
							 * 	buildings: [
							 * 		0 => {
							 * 			'type' 	=> 'home',
							 * 			'place' => 'Italy'
							 * 		},
							 * 		1 => {
							 * 			'type' 	=> 'factory',
							 *  		'place'	=> 'New York'
							 *  	}
							 * 	]
							 *
							 * adds to the building structure the direct keys 'type' and 'place' for each
							 * iteration. The above structure would become (in example for the first iteration)
							 *
							 * 	buildings: [
							 * 		0 => {
							 * 			'type' 	=> ['home'],
							 * 			'place' => ['Italy']
							 * 		},
							 * 		1 => {
							 * 			'type' 	=> ['factory'],
							 *  		'place'	=> ['New York']
							 *  	},
							 *  	type:	['home'],
							 *  	place:	['Italy']
							 * 	]
							 *
							 *
							 */
							$this->setVar($blockName, $value);

							// Processing and rendering the structure for each iteration
							$this->process();
							$tmpBufferArray[] = $this->render(true);
							
							$lastVariables = $value;
							
							// We don't need the sub items (type / place ) created previously so
							// we need to remove them.
							$this->clearSubvar($blockName);
							
							// Same fate for the iterator object.
							$this->clearVar('iterator');
							
							if(substr($blockName.".", 0, strlen($this->loopBreakFor.".")) == $this->loopBreakFor."."){
								if($blockName == $this->loopBreakFor) $this->loopBreakFor = '';
								break;
							}
								
						}
						
						$tmpBuffer = implode("", $tmpBufferArray);
						/*
						 * Restoring object status
						 */
						$this->restoreCurrentStatus($currentObjectStatus);
						/*
						 * Restoring the iterator
						 */
						if(!is_null($tempIterator)) $this->setVar('iterator', 		$tempIterator);

					}else{
						$tmpBuffer = '';
					}
					$buffer = str_replace($items[0].$loopBlock.'{' . self::KEYWORD_LOOP_END.'}', $tmpBuffer, $buffer);
						
					break;
				case self::KEYWORD_LOOP_BREAK:
					$replacement = $items[0];
					$buffer = str_replace($replacement, '', $buffer);
					$this->loopBreakFor = $value;
					break; 
				case self::KEYWORD_IF_START:
					list($ifBlock, $elseBlock) = $this->ifBlockSearch($buffer, $items[0], self::KEYWORD_IF_START, self::KEYWORD_IF_END, self::KEYWORD_IF_ELSE);
					$replacement = $items[0];
					$replacement .= $ifBlock;
					if($elseBlock!=''){ 
						$replacement .= '{'. self::KEYWORD_IF_ELSE.'}';
						$replacement .= $elseBlock;
					}
					$replacement .= '{'.self::KEYWORD_IF_END .'}';
					
					if($this->evaluate($value)){
						$buffer = str_replace($replacement, $ifBlock, $buffer); 
					}else{
						$buffer = str_replace($replacement, $elseBlock, $buffer);
					};
					break;
				case self::KEYWORD_PHP_BLOCK_START:
					$block = $this->endBlockSearch($buffer, $items[0],self::KEYWORD_PHP_BLOCK_START, self::KEYWORD_PHP_BLOCK_END);
					$replacement = $items[0].$block.'{'.self::KEYWORD_PHP_BLOCK_END .'}';
						
					ob_start();
					eval($block);
					$block = ob_get_clean();
					if($value!='EMPTY'){
						$this->setVar($value, $block);
						$block = '';
					}
					$buffer = str_replace($replacement, $block, $buffer);
						
					break;
				case self::KEYWORD_IFVAR_START:
						
					$block = $this->endBlockSearch($buffer, $items[0],self::KEYWORD_IFVAR_START, self::KEYWORD_IF_END);
					$replacement = $items[0].$block.'{'.self::KEYWORD_IF_END .'}';
					$value = trim($value);
					$evaluation = preg_split(' ',$value);
					$ifvVar1 = $this->parseVar($evaluation[0]);
					$ifvVar2 = $this->parseVar($evaluation[2]);
					$replaceSuccess = false;
					switch($evaluation[1]){
						case 'equal-to':
							$replaceSuccess = ($ifvVar1 == $ifvVar2);
							break;
						case 'less-than':
							$replaceSuccess = ($ifvVar1 < $ifvVar2);
							break;
						case 'greater-than':
							$replaceSuccess = ($ifvVar1 > $ifvVar2);
							break;
						case 'less-or-equal':
							$replaceSuccess = ($ifvVar1 <= $ifvVar2);
							break;
						case 'greater-or-equal':
							$replaceSuccess = ($ifvVar1 >= $ifvVar2);
							break;
						case 'different-to':
							$replaceSuccess = ($ifvVar1 != $ifvVar2);
							break;
						case 'exists':
							#$replaceSuccess = isset(self::$variables[$evaluation[0]]);
							$replaceSuccess = !is_null($this->getVar($evaluation[0], null));
							break;
					}
						
					if($replaceSuccess){
						$buffer = str_replace($replacement, $block, $buffer);
					}else{
						$buffer = str_replace($replacement, '', $buffer);

					};
					break;
				case self::KEYWORD_VAR:
					$result = $this->parseVar($buffer);
						
					# Modifica di Diego del 05-03-2010
					if($result[0]=='\{'.self::KEYWORD_VAR.'\:input\.html\}')
						$buffer = preg_replace('/' . $result[0] . '/', print_r($result[1], true) ,$buffer,1);
					else{
						$unescaped = stripslashes($result[0]);

						if(array_search($unescaped, self::$disallowedEscapeOn)!==false){
							$buffer = preg_replace('/' . $result[0] . '/', print_r($result[1], true),$buffer,1);
						}else{
							$buffer = preg_replace('/' . $result[0] . '/', str_replace('"', '&quot;', print_r($result[1], true) ),$buffer,1);
						}
					}
					# Fine modifica
						
					break;
				case self::KEYWORD_SETVAR:
					$result = $this->setVarRuntime($buffer);
					$buffer = preg_replace('/' . $result[0] . '/', (is_array($result[1]))?print_r($result[1], true):$result[1],$buffer,1);
					break;
				case self::KEYWORD_FUNCTION:
					$tmpValue = $value;
					$value = trim($value);
						
					$c = preg_match('/([a-z0-9]+)\\((.*)\\)$/i', $value, $subItems);
					$error =false;

					# Se la funzione si trova in linea con altri parametri potrebbe causare un errore di runtime,
					# quindi provo a correggere l'errore ma se non riuscissi a risolverlo notifico con un messaggio
					# user-friendly quanto accaduto e come è possibile risolvere il problema.

					if(count($subItems)<2){
						$error = true;
						while($i = strrpos($tmpValue, '}')){
							$tmpValue = substr($tmpValue,0, $i);
							$value = trim($tmpValue);
								
							$c = preg_match('/([a-z0-9]+)\\((.*)\\)/i', $value, $subItems);
							if(count($subItems)<2){
								$error = true;

							}else{
								$items[0] = '{' . self::KEYWORD_FUNCTION . ':' . $value .'}';

								$error =false;

							}
								
						}

					}
						
					if(!$error){
						$fnName = $subItems[1];
						$params = $subItems[2];
						$items[0] = preg_replace('/[^a-z0-9]/i', '\\\\\0', $items[0]);
						$value = $this->parseFunction($fnName, $params);
						$buffer = preg_replace('/' . $items[0] . '/', $value,$buffer);
					}else{
						applicationError(
							'Definizione errato della chiamata al metodo', 
							'&Egrave; stata definita nel modello una chiamata ad una funzione custom in modo inappropriato.', 
						$items[0],
							'Le cause di questo errore possono essere diverse:</p>
							<ul>
								<li>La riga del modello su cui è richiamata la funzione è troppo compelssa</li>
								<li>Una funzione deve cotnenere (anche in assenza di parametri) le parentesi tonde aperte e chiuse</li>
								 
							</ul>.');

					}
					break;
						
			}
		};

		
		if(!$this->isPlugin){
			$h = implode(self::$headers,"\n") . "\n";
			
			if((count(self::$headerScripts)>0 || count(self::$startupScripts)>0)  ){
				$s = '	<script type="text/javascript"><!--' ."\n";
				if(count(self::$headerScripts)>0){
					$s .= implode(self::$headerScripts,"\n") . "\n";
				}
				if(count(self::$startupScripts)>0){
					if(defined('HEADER_SCRIPT_USE_JQUERY') && HEADER_SCRIPT_USE_JQUERY ){
						$s .="jQuery('document').ready(function($){\n";
						$s .= implode(self::$startupScripts,"\n") . "\n"; 
						$s .="});";
					}else{
						$s .='		_.extend(\'alpha-startup\', {
										startup: function(){';
						$s .= implode(self::$startupScripts,"\n") . "\n";
						$s .= "} });\n\n";
					}
				}
				$s .= '--></script>';
				$h .= $s;
			}
			$buffer = str_replace('</head>', $h . "\n</head>", $buffer );
			
			$buffer = str_replace('href="/', 'href="' . APPLICATION_URL,  $buffer);
			$buffer = str_replace('src="/', 'src="' . APPLICATION_URL,  $buffer);
		}
		// Moved inside the conditional block.
		// So I will make replacements one time at all.
		// $buffer = str_replace('href="/', 'href="' . APPLICATION_URL,  $buffer);
		// $buffer = str_replace('src="/', 'src="' . APPLICATION_URL,  $buffer);



		$buffer = str_replace('@@ROOT/', APPROOT, $buffer);

		/*
		 * If I have to ignore cache why should I save the response in cache?
		 */
		if(!$this->ignoreCache) $this->saveCache($buffer);

		if($bufferedOutput) return $buffer;
		echo($buffer);

	}
	private function replaceNestedVar($value){
		if(preg_match_all('/\[\*([a-z0-9_\-\.]+)\*\]/i',  $value, $subItems)){
			for($i = 0; $i<count($subItems); $i++){
				#$value = str_replace($subItems[0][$i], self::$variables[$subItems[1][$i]], $value);
				$value = str_replace($subItems[0][$i], $this->getVar($subItems[1][$i]), $value);
			}
		}

		return $value;

	}
	private function setVarRuntime($buffer){

		if(preg_match('/{' .self::KEYWORD_SETVAR.':([a-z0-9_\-\.]+) ([^{}]+)}/i', $buffer, $items)){

			$newVar = $items[1];
			$value = $items[2];
			$value = $this->replaceNestedVar($value);
			$result = $this->getVar($value);

			if($result!='') $value = $result;
			$this->setVar($newVar, $value); 
			#self::$variables[$newVar] =  $value;
			$result = array(
				preg_replace('/[^a-z0-9]/i', '\\\\\0', $items[0]),
				''
			) ;
					
		}else{
				
			$result = '';
		}
		return $result;
	}
	/**
	 * Obtain the value stored in a template variable
	 * @param string $key
	 * @param string $ifUnavailable (optional): the value back if the variable is not available
	 */
	public function getVar($key, $ifUnavailable = '', $raw = false){
		if(isset(self::$variables[$key])){
			
			#$value = self::$variables[$key];
			$tmpVar = self::$variables[$key];
			
		}else{
			$var = preg_split('/\./', $key);
			# Modifica del 26-02-2010 di Diego La Monica
			# $tmpVar = $this->variables;
			$tmpVar = self::$variables;
			foreach ($var as $keys){
				
				$tmpVar = isset($tmpVar[$keys])?$tmpVar[$keys]:null;
				if(is_null($tmpVar))break;
				
			}
			
		}
		
		if(!$raw){
			if(is_array($tmpVar) && (isset($tmpVar[0]) || count($tmpVar)==1)){
				$tmpVar = $tmpVar[0];
			}
		}
		return is_null($tmpVar)?$ifUnavailable:$tmpVar;
	}

	/**
	 * Cerca la prima occorrenza di variabile CUTEML nel buffer
	 * applicando (se specificata) la trasformazione dal valore "@from" al valore "@to"
	 * @example {var:myVariable|@from "[A-Z]" @to "\1"}
	 * @param $buffer <b>string</b> è il buffer corrispondente alla vista corrente
	 * @return array [0] la trasformazione della variabile riscontrata in un formato accettato dalla sintassi Perl RegEx [1] il valore da sostituire
	 */
	private function parseVar($buffer){
		global $formatArray;

		preg_match('/{' .self::KEYWORD_VAR.':([a-z0-9_\-\.]+)(\\|(@(from)\\s+"([^"\\\]*(?:\\\.[^"\\\]*)*)"\\s?)?(\\s?@(to)\\s+"([^"\\\]*(?:\\\.[^"\\\]*)*)")?)?}/i', $buffer, $items);
		$value = $items[1];
		$value = $this->getVar($value);

		$from =''; $to = '';
		if(count($items)>2){
			if($items[4]=='from'){
				$from = $items[5];
				if($items[7]=='to'){
					$to = $items[8];
				}else{
					$to = '';
				}
			}else{
				$from = '';
				if($items[4]=='to'){
					$to = $items[5];
				}else{
					$to = '';
				}
			}
		}
		if($from!='' && $to!=''){

			global $formatArray;
				
			if(key_exists($from, $formatArray)) $from = $formatArray[$from];
			if(key_exists($to,   $formatArray)) $to = $formatArray[$to];

			$value = preg_replace('/'. $from.'/', $to, $value);
		}

		if($value==null || !isset($value)) $value ='';
		$result = array(
			preg_replace('/[^a-z0-9]/i', '\\\\\0', $items[0]),
			$value
		);

		return 	$result;
	}

	/**
	 * Elabora l'oggetto funzione CUTEML e ne restituisce il risultato
	 * @param $fnName <b>string</b> nome della funzione da eseguire presente nel path delle funzioni custom (o nelle funzioni di sistema se la custom non è presente)
	 * @param $params <b>array</b> è un array (non associativo) di parametri da fornire alla funzione
	 * @return string il risultato della funzione
	 */
	private function parseFunction($fnName, $params){
		// Splitting the params string into multiple parameters
		preg_match_all('/("[^"\\\]*(?:\\\.[^"\\\]*)*")|(\'[^\'\\\]*(?:\\\.[^\'\\\]*)*\')|([^,]+)/i', $params, $params);
		$params = $params[0];
		for($i=0; $i<count($params);$i++){
				
			$params[$i] = trim($params[$i]);
			if(substr($params[$i],0, strlen(self::KEYWORD_FUNCTION)+1) == self::KEYWORD_FUNCTION .':'){
				// è una funzione devo rielaborarla ricorsivamente
				$params[$i] = substr($params[$i], strlen(self::KEYWORD_FUNCTION)+1);
				$value='';
				$nestingLevel = 0;
				for($j = $i; $j<count($params);$j++){
					if($value!='' && str_replace(')','',$params[$j])!='') $value.=',';
					$value.= trim($params[$j]);
					if(substr($params[$j],0, strlen(self::KEYWORD_FUNCTION)+1) == self::KEYWORD_FUNCTION .':') $nestingLevel+=1;
					if(substr($value,-1,1)==')'){
						$checkClosures = strrev($value);
						while(substr($checkClosures,0,1)==')'){
							$nestingLevel-=1;
							$checkClosures = substr($checkClosures,1);
						}
						if($nestingLevel<=0){
							# devo ridurre il numero di parametri per la funzione principale
							$tmpArray = array();
							for($k=0; $k<count($params); $k++){
								if($k<$i || $k>$j) $tmpArray[] = $params[$k];
								if($k==$i) $tmpArray[] = $value;
							}
							$params = $tmpArray; #array_splice($params, $i+1, $j-$i);
							break;
						}

					}
						
				}
				$c = preg_match('/([a-z0-9]+)\\((.*)\\)$/s', $value, $subItems);
				$subFnName = $subItems[1];
				$subParams = $subItems[2];

				$params[$i]= $this->parseFunction($subFnName, $subParams);
			}else if(
			substr($params[$i], 0, 1)=='"' ||
			substr($params[$i], 0, 1)=='\'' ||
			preg_match('/^\d+$/', $params[$i])){
				#Forse da qui non è necessario passare, verificare
				if(
				(substr($params[$i], 0, 1)=='"' &&  ((substr( strrev($params[$i]),0, 1)!= '"') || substr( strrev($params[$i]),1, 1)=='\\')) ||
				(substr($params[$i], 0, 1)=='\'' && ((substr( strrev($params[$i]),0, 1)!='\'') || substr( strrev($params[$i]),1, 1)=='\\')) ||
				(substr( strrev($params[$i]),0, 1)=='\\') ){
					if((substr( strrev($params[$i]),0, 1)=='\\')){
						$params[$i] =  substr($params[$i], 0, strlen($params[$i])-1) . ','.$params[$i+1];
						$params[$i+1] = null;
						$i = $i-1;
					}else{
						if(isset($params[$i+1])){
							$params[$i] .= $params[$i+1];
							$params[$i+1] = null;
							$i = $i-1;
						}
					}
					$tmpParams = $params;
					$params = array();
					$offset=0;
					for($j = 0; $j<count($tmpParams); $j++){
							
						if($tmpParams[$j]==null && $j>$i)			$offset += 1;
						else						$params[$j-$offset] = $tmpParams[$j];
					}

				}

				// è una stringa o un numero quindi devo passare il suo valore tramite eval
				if($params[$i]=='')$params[$i] = '""';
				$params[$i] = '$params[$i] = ' . $params[$i] . ';';
				eval($params[$i]);

			}else{
				$params[$i] = $this->getVar($params[$i]);
			}
		}

		$fnRoot = APPLICATION_CUSTOM_FUNCTION_BASEDIR .'/';
		if(!file_exists($fnRoot.$fnName . '.php')) $fnRoot = FUNCTIONSROOT;
		if(file_exists($fnRoot.$fnName . '.php')){
			require_once $fnRoot.$fnName . '.php';
				
			$f = new $fnName();
			
			# A little bit faster than for() statement
			foreach($params as $i => $param){
				$f->addParameter($param);
			}
			$result = $f->execute();
			
		}else{
			applicationError(
				'Il metodo chiamato non è disponibile nelel funzioni custom o nelle funzioni core', 
				'&Egrave; stata definita nel modello una chiamata ad una funzione non esistente.', 
			$fnName,
				'Verificare se il file di funzione è presente nel core (' . CORE_ROOT .'/functions/) oppure
				nella cartella dell\'applicazione (' . APPLICATION_CUSTOM_FUNCTION_BASEDIR . ')');
		}
		return $result;
	}
	/**
	 * Set multiple variables
	 * @param any $object: associative array/object with the list of variable to set.
	 * @param string $prefix (optional). default = '' if specified the method will become an alias of setVar($prefix, $object)
	 */
	public function setMultipleVar($object, $prefix=''){
		
		if($prefix!='') {
			$this->setVar($prefix, $object);
		}else if(is_array($object) || is_object($object)){
			foreach($object as $key => $value){
				$this->setVar($key, $value);
			}
		}
	}
	
	/**
	 * Rimuove tutti gli header che dovranno essere passati al modello
	 * @return null
	 */
	public function resetHeader(){
		
		self::$headers = array();
		self::$headerScripts = array();
		self::$startupScripts =array();

	}
	/**
	 * Remove all variables from the model
	 */
	public function clearAllVar(){

		# Modifica del 26-02-2010 di Diego La Monica
		# $this->variables = null;
		self::$variables = null;
		# Fine Modifica
	}
	/**
	 * Remove all variables with specific prefix.
	 * If $prefix is empty the method will works as clearAllVar() method
	 * @param string $prefix il prefisso delle variabili da rimuovere
	 * @param bool $exactToo if true the value of variable and its subvariables will be removed otherways only the direct value will be removed.
	 */
	public function clearVar($prefix = '', $exactToo = false ){

		if($prefix=='') {
			$this->clearAllVar();
		}else{
			# Improvement based on new $variables array structure
			$this->createVar($prefix, null, self::$variables, $exactToo?'replace':'unset');
		}

	}
	public function clearSubvar($prefix){

		$subvar = $this->getVar($prefix, array(), true);
		foreach($subvar as $key => $value){
			if(!is_numeric($key) ){
				unset($subvar[$key]);
				#$this->clearVar("$prefix.$key", true);
			}
		}
		/*
		 * Faster than using clearVar method.
		 */
		$this->replaceVar($prefix, $subvar, self::$variables);
		
	}
	
	/**
	 * Metodo interno per la valutazione di una condizione
	 * @param string $condition codice PHP della condizione da valutare
	 * @return boolean
	 * @todo make evaluate more secure/safer
	 */
	private function evaluate($condition){
		$var = self::$variables;
		
		if($condition!=''){
			$c = "\$___ModelEvaluationCondition= ($condition);";
			@eval($c);
			
		}
		
		return isset($___ModelEvaluationCondition)?$___ModelEvaluationCondition:false;

	}

	/**
	 * Cerca la chiusura di un blocco strutturato CUTEML
	 * @param $buffer <b>string</b> il buffer della vista corrente
	 * @param $item <b>string</b> l'elemento di inizio blocco dal quale partire
	 * @param $keyword_start <b>string</b> Keyword che identifica l'apertura del blocco
	 * @param $keyword_end <b>string</b> Keyword che identifica la chiusura del blocco
	 * @return <b>string</b> il contenuto del blocco esclusi gli elementi di apertura e chiusura
	 */
	private function endBlockSearch($buffer, $item , $keyword_start, $keyword_end){

		$i = strpos($buffer, $item);
		$j = strpos($buffer, '{' . $keyword_end . '}');
		$i = $i+ strlen($item);
		# Changes for if then else

		if($j===false) return '';
		$block = substr($buffer, $i, $j- $i);
		$endLoopIndex	= preg_match_all('/{' . $keyword_end .'}/', $block, $matches);
		$startLoopIndex = preg_match_all('/{' . $keyword_start .':([^}]+)}/', $block, $matches);

		while($startLoopIndex!=$endLoopIndex){
			
			$j = strpos($buffer, '{' . $keyword_end . '}',$j+1);
				
			if($j===false) $j=strlen($buffer)+ $i-$j;
			$block = substr($buffer, $i, $j- $i);
			$endLoopIndex	= preg_match_all('/{' . $keyword_end .'}/', $block, $matches);
				
			$startLoopIndex = preg_match_all('/{' . $keyword_start .':([^}]+)}/', $block, $matches);
				
		}

		return $block;
	}

	private function ifBlockSearch($buffer, $item , $keyword_start, $keyword_end, $keyword_else){
	
		// Identify the endif related to this if/endif block  
		$block = $this->endBlockSearch($buffer, $item, $keyword_start, $keyword_end);
		
		$blocks = array();
		$blocks[0] = array (
			'if' => array('starts' => 0, 'ends' => strlen($block)),
			'else' => null
		);
		
		// Search all nested if
		if(preg_match_all('/{' . $keyword_start .':([^}]+)}/', $block, $matches, PREG_OFFSET_CAPTURE)){
			
			foreach($matches[0] as $index => $match){
				$subBlock = $this->endBlockSearch($block, $match[0], $keyword_start, $keyword_end);
				$blockEndsTo = strlen($subBlock)+ strlen($match[0]) + strlen('{'.$keyword_end.'}')+$match[1];
				
				$blocks[$match[1]] = array(
					'if' => array( 'starts'=> $match[1], 'ends' => $blockEndsTo),
					'else' => null
				);
			}
		}
		$return = array('if' => '', 'else' => '');
		if(preg_match_all('/{' . $keyword_else .'}/',$block, $matches, PREG_OFFSET_CAPTURE)){
			// There are a lot of else (or at least 1)
			$current = 0;
			foreach($matches[0] as $current => $else){
				// Scan all else
			
				$elseOffset = $else[1];
				$maybe= 0;
				foreach($blocks as $startRow => $data){
					if(	$data['if']['starts']<$elseOffset && 
						$data['if']['ends']>$elseOffset
					) $maybe = $startRow;
					
					
				}
				$blocks[$maybe]['else'] = array('starts' => $elseOffset+ strlen("{".$keyword_else."}"), 'ends' => $blocks[$maybe]['if']['ends']);
				$blocks[$maybe]['if']['ends'] = $elseOffset;
				 
			}
			
			$return[0] = substr($block, $blocks[0]['if']['starts'], $blocks[0]['if']['ends']);
			if($blocks[0]['else']!=null){
				$return[1] = substr($block, $blocks[0]['else']['starts'], $blocks[0]['else']['ends']);
			}else{
				$return[1] = '';
			}
			
		}else{
		
		 	$return[0]   = $block;
			$return[1] = '';
		
		}
		return $return;
		
	}

}

?>